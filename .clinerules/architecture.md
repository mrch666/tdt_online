# Архитектурные решения для проекта FastAPI

## Структура проекта
```
fastapi/
├── app/
│   ├── __init__.py
│   ├── main.py              # Точка входа приложения
│   ├── database.py          # Настройки подключения к БД
│   ├── models.py            # Модели SQLAlchemy (только дополнять связи)
│   ├── routers/             # Маршруты API
│   │   ├── modelgoods.py
│   │   ├── modelgoods_images.py
│   │   ├── modelgoods_description.py
│   │   └── ...
│   ├── schemas/             # Pydantic схемы
│   │   ├── modelgoods.py
│   │   ├── modelgoods_images.py
│   │   └── ...
│   ├── static/              # Статические файлы
│   └── templates/           # HTML шаблоны
├── tests/                   # Тесты
├── .env                     # Переменные окружения
├── .env.example            # Пример переменных окружения
└── requirements.txt        # Зависимости
```

## Принципы проектирования

### 1. Разделение ответственности
- **Модели (models.py)**: Только определение структуры БД, без бизнес-логики
- **Схемы (schemas/)**: Валидация входных/выходных данных
- **Маршруты (routers/)**: Обработка HTTP запросов
- **Бизнес-логика**: В отдельных сервисных классах или функциях

### 2. Работа с базой данных
- Использовать SQLAlchemy ORM для всех операций с БД
- Все обращения к таблицам использовать с `quote=True`
- Имена таблиц и полей строго в нижнем регистре
- Хранимые процедуры вызывать через `text()` с явным указанием параметров

### 3. Обработка ошибок
- Использовать стандартные HTTP коды ошибок
- Логировать все ошибки с деталями параметров
- Возвращать понятные сообщения об ошибках пользователю
- Не раскрывать внутренние детали реализации в ошибках

### 4. Безопасность
- Валидация всех входных данных через Pydantic схемы
- Проверка прав доступа к ресурсам
- Защита от SQL-инъекций через параметризованные запросы
- Безопасная работа с файлами

## Конкретные архитектурные решения

### 1. Загрузка файлов
```python
# Правильный подход:
# 1. Валидация входных данных
# 2. Проверка существования ресурса
# 3. Сохранение через хранимую процедуру
# 4. Обновление записи в БД
# 5. Возврат результата
```

### 2. Работа с хранимыми процедурами
```python
# Всегда использовать точные имена параметров
sql = text("""SELECT * FROM "wp_SaveBlobToFile"(:iPathDB, :iPath, :iBlob)""")
result = db.execute(sql, {
    'iPathDB': 'C:\\Program Files (x86)\\tdt3\\bases\\img',
    'iPath': 'filename.jpg',
    'iBlob': file_content
})
```

### 3. Логирование
- Использовать `logger.getLogger("api")` для единообразия
- Логировать длину и типы параметров при отладке
- Разделять логи по уровням (DEBUG, INFO, ERROR)

### 4. Конфигурация
- Все настройки через переменные окружения
- Файл `.env` для локальной разработки
- `.env.example` с примерами значений

## Ограничения и требования

### 1. Неизменяемая структура БД
- Нельзя изменять существующие таблицы и поля
- Можно только добавлять связи между таблицами
- Все имена в нижнем регистре с `quote=True`

### 2. Типы данных
- `modelid`: всегда CHAR(12), ровно 12 символов
- Пути: использовать оригинальные системные пути Windows
- BLOB: для передачи бинарных данных

### 3. Пути и расположение
- `fbclient.dll`: `C:\Program Files (x86)\tdt3\fbclient.dll`
- Изображения: `C:\Program Files (x86)\tdt3\bases\img`
- Конфигурация через `.env` файл

## Best Practices
1. **Документация**: Добавлять docstrings ко всем функциям и классам
2. **Тестирование**: Писать тесты перед внесением изменений
3. **Логирование**: Детальное логирование для отладки
4. **Безопасность**: Валидация всех входных данных
5. **Производительность**: Использовать пагинацию для больших наборов данных